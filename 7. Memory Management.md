## Chapter 7: Memory Management

- __Bare Machine__ - A system in where the designer is to decide how the memory should be addressed. This kind of system is used for dedicated system such as a computer controlling a plant. 

- The typical computer utilizes a __Resident Monitor__, where part of the memory is used by the operating system. In such system, one part of the memory is used by the __operating system__ and the remaining part of the memory is used to load user programs (__User Area__). 

- A user program is not permitted to touch the memory that is used by the Operating System. This is achieved by having a __Fence Address__. The fence address acts a fence or a marker that cannot be surpassed by the user program.

- There are two ways to keep checking if a user program is not surpassing the Fence Address: Software Check or Hardware check. Software check is slow. A hardware solution checks in parallel whether the address generated by the CPU has jumped the Fence Address. If yes, then set a trap, if no then allows for the CPU to use the memory. 

- The problem with the hardware solution is that it is fixed. Meaning that the hardware might not be compatible with an operating system that requires more or less allocated memory. A solution is to use a __Fence Register__ which is reloaded if the operating system is upgraded. 

- Memory can be divided into different areas besides just the o/s and user area. One of the areas called __buffer1__ can be used to swap out jobs (terminate jobs and put them back to secondary storage). The other area called __buffer 2__ can be used to swap in job from a secondary storage into main memory. The other areas (o/s and user) work separately. The user area is now able to take a process that has completed its CPU burst and move it into _buffer 1_. 


- To divide and protect the different memory areas a fence address is also used. A job in buffer 2 does not have to be transferred to user area. The fence address can be shifted up and encompass the area where the job is located (buffer 2) so that the user area can now execute that job. More memory partitions allow for better memory management. 

- __Multiprogramming with Fixed number of Tasks__ - here main memory will partitioned into many fixed segments or areas, including the o/s area. An instruction pointer can be used to make different areas of the memory become active. In this case, a segment must be protected using two registers: A __lower bound register__ and an __upper bound register__. 

- If the CPU process is trying to access an area below the lower bound address and above the upper bound address, then that process is not allocated memory. 

- A __base register__ and a __limit register__ can be used to check if the CPU generated address is requesting to access a part of the memory that is not allowed for that process. If the CPU logical address is less than the limit register, then that logical address is added to the Base address and given access to the physical address in memory. If the logical address is more that the limit address, then is send to a trap. 

- The way the operating system decides where a job is loaded into main memory is based on the fixed size of the partition in memory. 

- __First Fit Algorithm__ - A partition is allocated fully to a job or not based on an algorithm that checks and allocated which is the first segment of the memory that is more than or equal to the size required by the process. Because it is fixed, a partition cannot be allocated to other jobs when a job has been loaded into it. There could be a case where the memory partition allocated to a process is bigger in size than what the process requires. The remaining allocated memory is wasted and also referred to as an __internal fragmentation__.


- __Best Fit Algorithm__ - allocates the memory partition that leads to the minimum internal fragmentation. This means that it has to check _all segments_ in memory to choose the best one for the size required by the process. The complexity of this algorithm is a lot higher than the previous algorithm. 

- There could be a case when the partitions in memory are all smaller in size than what is required by a process. In such scenario, there is a case of __external fragmentation__ because there are free memory partition of which not can be used. 

- A __memory module__ keep track on information about the main memory partition sizes and statuses. 

- The status (Free / Busy) of each memory partition is kept in what is called a __Partition Allocation Table__.
