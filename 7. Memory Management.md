## Chapter 7: Memory Management

- __Bare Machine__ - A system in where the designer is to decide how the memory should be addressed. This kind of system is used for dedicated system such as a computer controlling a plant. 

- The typical computer utilizes a __Resident Monitor__, where part of the memory is used by the operating system. In such system, one part of the memory is used by the __operating system__ and the remaining part of the memory is used to load user programs (__User Area__). 

- A user program is not permitted to touch the memory that is used by the Operating System. This is achieved by having a __Fence Address__. The fence address acts a fence or a marker that cannot be surpassed by the user program.

- There are two ways to keep checking if a user program is not surpassing the Fence Address: Software Check or Hardware check. Software check is slow. A hardware solution checks in parallel whether the address generated by the CPU has jumped the Fence Address. If yes, then set a trap, if no then allows for the CPU to use the memory. 

- The problem with the hardware solution is that it is fixed. Meaning that the hardware might not be compatible with an operating system that requires more or less allocated memory. A solution is to use a __Fence Register__ which is reloaded if the operating system is upgraded. 

- Memory can be divided into different areas besides just the o/s and user area. One of the areas called __buffer1__ can be used to swap out jobs (terminate jobs and put them back to secondary storage). The other area called __buffer 2__ can be used to swap in job from a secondary storage into main memory. The other areas (o/s and user) work separately. The user area is now able to take a process that has completed its CPU burst and move it into _buffer 1_. 


- To divide and protect the different memory areas a fence address is also used. A job in buffer 2 does not have to be transferred to user area. The fence address can be shifted up and encompass the area where the job is located (buffer 2) so that the user area can now execute that job. More memory partitions allow for better memory management. 

- __Multiprogramming with Fixed number of Tasks__ - here main memory will partitioned into many fixed segments or areas, including the o/s area. An instruction pointer can be used to make different areas of the memory become active. In this case, a segment must be protected using two registers: A __lower bound register__ and an __upper bound register__. 

- If the CPU process is trying to access an area below the lower bound address and above the upper bound address, then that process is not allocated memory. 

- A __base register__ and a __limit register__ can be used to check if the CPU generated address is requesting to access a part of the memory that is not allowed for that process. If the CPU logical address is less than the limit register, then that logical address is added to the Base address and given access to the physical address in memory. If the logical address is more that the limit address, then is send to a trap. 

- The way the operating system decides where a job is loaded into main memory is based on the fixed size of the partition in memory. 

- __First Fit Algorithm__ - A partition is allocated fully to a job or not based on an algorithm that checks and allocated which is the first segment of the memory that is more than or equal to the size required by the process. Because it is fixed, a partition cannot be allocated to other jobs when a job has been loaded into it. There could be a case where the memory partition allocated to a process is bigger in size than what the process requires. The remaining allocated memory is wasted and also referred to as an __internal fragmentation__.


- __Best Fit Algorithm__ - allocates the memory partition that leads to the minimum internal fragmentation. This means that it has to check _all segments_ in memory to choose the best one for the size required by the process. The complexity of this algorithm is a lot higher than the previous algorithm. 

- There could be a case when the partitions in memory are all smaller in size than what is required by a process. In such scenario, there is a case of __external fragmentation__ because there are free memory partition of which not can be used. 

- A __memory module__ keep track on information about the main memory partition sizes and statuses. 

- The status (Free / Allocated) of each memory partition is kept in what is called a __Partition Allocation Table__.

- Another type of memory management is called __Multiprogramming with Variable number of Tasks__ (MVT). In such case, we don't have a fixed number of partitions. In fact, in MVT, the number and size of partition vary depending on the size requirement from different jobs.  

- In the MVT, initially (no jobs) there will be two partitions in memory: O/S area and User area.

- Assuming we have the following jobs:

```Pascal
// memory size 256K
// initial memory allocation
O/S Partition = 40K
User Partition = 216K

// memory requirements for jobs using a FCFS scheduling
J1 = 60K , 10 time units (CPU burst time)
J2 = 100K, 5 time units
J3 = 30K, 20 time units
J4 = 70K, 8 time units
J5 = 50K, 15 time units
J6 = 60K, 9 time units

// Allocation happens the following way

// J1 allocation
2 Partition: 40K --> 100K
Unallocated Partition : 156K

// J2 Allocation
Partition: 100K --> 200K
Unallocated Partition: 56K

// J3 Allocation
Partition: 200K --> 230K
Unallocated Partition: 26K
```

- No other jobs can be loaded into memory since all of them exceed the size of the remaining partition. The remaining unallocated partition become an external fragmentation. 

- After 5 time units, J2 will complete execution and the partition held by J2 will change its state to unallocated.

```Pascal
O/S Partition: 0 --> 40K

// J1 allocation
2 Partition: 40K --> 100K
Unallocated partition: 100K --> 200K (after J2 released it)

// J3 Allocation
Partition: 200K --> 230K
Unallocated Partition: 26K (230K - 256K)

// J4 Allocation
Partition: 100K --> 170K
Unallocated Partition: 30K (170K - 200K) // this makes two unallocated partitions in memory
```

- After 5 more time units, J1 will complete execution

```Pascal
O/S Partition: 0 --> 40K

Unallocated partition: 60K (40K - 100K) (after J1 released it)

// J4 Allocation
Partition: 100K --> 170K
Unallocated Partition: 30K (170K - 200K) 

// J3 Allocation
Partition: 200K --> 230K
Unallocated Partition: 26K (230K - 256K)

// J5 Allocation
Partition: 40K --> 90K
Unallocated Partition: 10K (90K - 100K)
```

- In the above given scenario, there is a total of 66K of memory which is unallocated. The remaining job only requires 60K. In order to use the remaining memory, all the free unallocated partition can be compacted together contiguously to make a bigger partition (size: 66K). Such technique is called __Memory Compaction__. After memory compaction jobs _J5_, _J4_, _J3_ and _J6_ will occupy a total of 250K memory with a remaining unallocated partition of size 6K.

- In the MVT, two tables are kept: A partition allocation table and a __free area table__ (containing the free unallocated spaces). Free area table contains the size of the area and the starting address of the partition.

- In MVT, you can allow internal fragmentation by merging a very small free area to an already allocated partition. This may avoid some cost.

- Memory compaction is a very costly solution. To come up with a better solution the __Paged Memory Management__ technique was introduced.

- In paged memory management, every process is divided into a number of pages. Processes are divided into a __number of pages__. Memory is divided into a __number of frames__. The page size is the same size as the frame size.

- Any page can be loaded into any of the frames. But there has to be some mapping stating in which frames in memory those pages were loaded. From a frame number it is possible to find out the physical address on the frame in memory where the job pages were allocated. 

- Every pages a _P_ number of bytes (Page size) with a logical address _L_. A logical address has two components: a page number _p_ and an offset/displacement _d_ within that page. This information is stored in a __Page Map Table (PMT)__ Those components are calculated as follows:

```Pascal
// logical address calculation
p = L div P // integer division
d = L mod P

// physical address calculation
Physical address = (f-1) * P + d
```

- Using the paging technique is beneficial because a job's pages can be loaded into memory frames without those frames having to be contiguous as in the previous technique (MFT) or (MVT). This also avoids the problem and complexity of compaction.

- In PMM, there will be internal fragmentation if the page size if (p = L div P) have a remainder. The maximum number of internal fragmentation is equal to (P - 1).

- In PMM, the __modular structure__ of the program is broken. 

- Instead of having pages, a job is broken down in segments that contain specific modules of the program. Such technique is called __Segmented Memory Management__. 

